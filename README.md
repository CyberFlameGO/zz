![logo](logo.png?raw=true)

Drunk Octopus - It compiles, ship it
====================================

ZZ (drunk octopus) is a dialect of C, inspired by rust

It's main use case is embedded systems, where we still program C out of desperation, because nothing else actually works.
You can also use it to build cross platform libraries. The build and linking concept is biased towards exporting a clean api.

[![Build Status](https://travis-ci.org/aep/zz.svg?branch=master)](https://travis-ci.org/aep/zz)

### too long didn't try

```bash
cd examples/hello
cargo run run
```


### the basic ideas

#### plain C ABI

ZZ emits plain C and it will always do that. It is one of the main reasons it exists.
It can help abstracting compiler specifics, but will always emit C into a C compiler which will then emit the binary.

most modern languages have has their own ABI, deviating from C, even C++ isn't really compatible with C.
Usually you can still glue all languages into another language somehow using api generators.
But with ZZ being plain C, all you do is include the header.
If you're glueing zz code into a non C language, you might not even want the header.
All struct sizes are exported as RO symbol, so you can just allocate a bytearray and use functions on it.

There is no stack unwinding (C++, rust), and no coroutines (go), so all code emits to plain ansi C
with no requirements towards compiler features.
ZZ works nicely with vendor provided closed source compiler for obscure systems. Like... esp8226.

#### safety and correctness. there is no heap

allocating unconstrained resources based on external input not known at compile time is a terrible idea.
Nothing prevents you from calling malloc() manually of course, but ZZs design is built around not doing that.
The entire language is designed around convenient use of constrained stack variables;

Instead we track stack memory using annotations. Every piece of memory has tags, most of which are autogenerated.
The compiler will complain if it cannot prove code is memory safe at compile time,
and will ask you to add more runtime checks.

This goes way beyond the hand waving approach of C with its land of "undefined behaviour".
In ZZ, undefined behaviour is not correct code, and should not compile.

Tooling for robustness is first class. We have testing built in.
All test binaries are by default built with address sanitization enabled,
which already converts alot of undefined behaviour into well defined crashes.

Fuzzing is another great weapon against subtle bugs, and all test cases you write are automatically used
for guided fuzzing, that is more effective than simple randomness.

#### namespaces, autogenerated headers and declaration ordering

really modern language has headers or semantically relevant declaration order and neither does ZZ.
but since it interacts with raw C nicely, it also emits headers, and orders declarations so a c compiler likes them.

ZZ puts module namespaces into the C symbol using underscores instead of mangling.
so my::lib::hello becomes my_lib_hello, which is C convention.

### how it looks


```C++
using errors;
using libc::stdint::{uint32_t as u32};

struct Beep {
    u32 a;
}

fn some_helper(errors::Error* err, u32 mut* bob) -> u32 {
    printf("lol\n");
    if (bob) {
        *bob = add(horst(), foo);
        printf("bob %d\n", *bob);
    }
    return 32;
}

export const fn horst() -> u32 {
    return 3;
}

```

### language reference

#### top level declarations: fn, struct

fn delares a function.
struct declares a struct.
nothing fancy here.

#### macro

macro definitions are almost like C's #define but slightly less ugly

```C
macro CHECK(e) {
    if ((e) != 0) {
        printf("oh noes!\n");
    }
}
```

any C syntax is allowed within the body, without having to do the ugly newline escape.
But unlike C, a macro must close all brackets it opens.
this intentionally disables some rather insane use cases.

#### storage: const, static, atomic and thread_local

const and static work exactly like in rust, but with C syntax.

```C
export const uint32_t foo = 3;
static mutable float blarg = 2.0/0.3;
thread_local mutable bool bob = true;
atomic mutable int marvin = 0;
```

const is inlined in each module and therefor points to different memory in each module.
static has a global storage location, but is private to the current module.

in effect, there is no way to have declare a shared global writable variable.
ZZ has no borrowchecker, and the restriction has nothing to do with preventing multithread races.
Instead the declarations are selected so that the resulting exported binary interface can be mapped to any other language.

if you need to export a global writeable memory location (which is still a bad idea, because threads),
you can define a function that returns a pointer to the local static.

thread_local and atomic are mapped directly to the C11 keywords.
ZZ can use nicer keywords because there are no user defined names at the top level.

#### visibility: pub, export

by default all declarations are private to a module

"export" can be used to make sure the declaration ends in the final result. that is in the binary and the export header.

"pub" marks a declaration as local to the project. it is usable in other zz modules, but not exported into the resulting binary


#### mutability: const, mut

by default, everything is const. this is the opposite of C. the mut keyword is used to make a global variable, or function argument mutable.


#### struct initialization


identical to C with the minor difference that you have to explicitly state the type, like rust.
To prepare for type elision, all expressions have to have a known type.

```C
struct A {
    int a;
    int b;
}

fn main() {
    A a = A{
        .a = 2,
    };
}
```

#### conditional compilation / preprocessor

Like in rust, the prepro is not a string processor, but rather executed on the AST  **after** parsing.
This makes it behave very different than C, even if the syntax is the same as C.

The right hand side of #if is evaluated immediately and can only access preprocessor scope.

```C
struct A {
    int a;
#if def("TEST")
    uint proc;
#elif def("MAYBE")
    int proc;
#else
    void* proc;
#endif
}
```

Every branch of an #if / #else must contain a completed statement,
and can only appear where a statment would be valid,
so this is not possible:

```C
pub fn foo(
#if os("unix")
)
#endif
```

note that even code that is disabled by conditions must still be valid syntax. It can however not be type checked,

#### a note on west-const vs east-const

ZZ enforces east-const. C is not a formally correct language, so in order to make ZZ formally correct, we have to make some syntax illegal.
In this case we sacrifice west-const, which is incosistent and difficult to comprehend anyway.

west-const with left aligned star reads as if the pointer is part of the type, and mutability is a property of the pointer (which it is).

```C++
    int mut* foo;
    foo = 0; // compile error
    *foo = 0 // valid
```

unless you want to apply mutability to the local storage named foo

```C++
    void * mut foo;
    foo = 0; // valid
    *foo = 0 // compile error
```

Coincidentally this is roughly equivalent to Rust, so rust devs should feel right at home.
Even if not, you will quickly learn how pointer tags works by following the compiler errors.


#### annotations

ZZ has type annotations.
They are key-value pairs (with default empty value) that are attached to types and local names used throughout compilation and type checking,
but they will never be emitted into the C interface.

examples of built-in predicares are "mutable", "initialized" and "safe"

A variable that is not marked as "initialized", cannot be used in most contexts, except as left hand side in an assignment.

A pointer that is not safe, cannot be dereferenced.

Because automatic annotation is still in early stage, you will do manual annotation alot using the 'is' keyword.

```C
fn bla(A mut* a) {
    if (a != 0) {
        a is safe;
        a->a = 3;
    }
}
```

#### typestate

we can use annotations to define states for types, which neatly lets you define which calls are legal on which
type at a given time in the program without ANY runtime code.


```C++
fn open(int set<open> mut* a) {
    *a = 1;
}

fn read(int require<open> mut* a) -> int {
    return *a;
}

fn close(int unset<open> mut* a) {
    *a = 0;
}
```

the above example defines a type state transition that is legal: open -> read -> close
any other combination will lead to a compile error, such as read before open.
Also not calling close while dropping a will lead to the lifetime checker emitting a warning.

#### fntype

function pointers are difficult to do nicely but also make them emit to C code well, so they don't really exist in ZZ.
instead you declare a function to be a type instead of a concrete implementation.
An fntype is emited as typedef, and therefore becomes a regular pointer type for both the C compiler and the ZZ memory tracker;

```C++
fntype rand_t() -> int;

fn secure_random() -> int {
    return 42;
}

fn main() {
    rand_t rand = secure_random;
}

```

closures do not exist in ZZ. One reason being that the C output would be difficult to use in other raw c code.
But the biggest reason is that most usage of closures is for capturing scope state.
That only really works well with garbage collected languages, otherwise its difficult to reason about (see rust).
In ZZ we instead explicitly track all state in structs and simply use plain stateless functions.


#### metaprogramming or templates: tail variants


technically zz does not have metaprogramming. template functions blow up code size and are difficult to export as plain C types.
instead zz makes code reusable by allowing allocations of structs to be larger than their member sizes.

We call this the "tail". And it can be used to make functions on fixed size arrays reusable for other sizes.

here's the String type:

```C++
export struct String+ {
    usize   len;
    char    mem[];
}
```

A + sign behind the name indicates this type has a tail.
The tail here is mem, which is specified as array with no size.

a length function could be implemented with this signature:

```C++
fn len(String+t mut * self) {
    return t;
}
```

again, the + indicates a tail. in this case, the tail size is bound to a local variable named t,
which can be used in the function body.

when allocating a new stack variable of type String, you also allocate a tail on the same stack

```C++
    String+100 s = {0};
    string::append(&s, "hello");
    string::append(&s, "world");
    printf("%.*s", s.len, s.mem);
```

again, + means tail, but here we specify an ineteger value of exact numbers of char we would like to add.
the tail is measured in number of elements of whatever is the last unsized element in the struct, not in bytes.

String can dynamically expand within the tail memory. in this case, we append some stuff to the string, without ever allocating any heap.
simply returning from the current function will clear up any memory used, without the need for destructor ordering or signal safety.
