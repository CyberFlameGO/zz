using libc::stdint::{size_t, uint8_t};
using libc::stdlib::{abort};
using libc::string::{memset};
using libc::stdio;

struct Pool {
    size_t      slab;
    size_t      count;
    uint8_t*    free;
    uint8_t*    pool;
}


pub fn size(size_t slab, size_t count) -> size_t {
    return sizeof(Pool) + (slab * count) + (count / 8) + 1;
}

pub macro MAKE (NAME, SLAB, COUNT) {
    char NAME [size(SLAB,COUNT)];
    init(NAME, SLAB, COUNT);
}

pub fn init(mut char* b, size_t slab, size_t count) {
    memset(b, 0, sizeof(Pool) + slab * count + count / 8 + 1);
    Pool* self = (Pool*)b;

    self->slab  = slab;
    self->count = count;
    self->free  = ((uint8_t*)b) + sizeof(Pool);
    self->pool  = self->free + count / 8 + 1;
}

pub fn alloc(mut char* b) -> void* {
    Pool* self = (Pool*)b;
    for (int i = 0; i < self->count; i+=1 ) {
        if ((self->free[i/8] & (1 << (i%8))) == 0) {
            self->free[i/8] |= (1 << (i%8));
            return self->pool + (i * self->slab);
        }
    }
    return 0;
}

pub fn release(mut char* b, void* mem) -> void* {
    Pool* self = (Pool*)b;

    size_t slot = ((uint8_t*)mem - self->pool) / self->slab;

    if (slot >= self->count || (self->pool + (self->slab * slot)) != mem) {
        fprintf(stderr, "internal error: pointer %x passed to fl:free was never allocated from this fl pool\n", mem);
        abort();
    }

    self->free[slot / 8] &= ~(1 << (slot % 8));

    return 0;
}


