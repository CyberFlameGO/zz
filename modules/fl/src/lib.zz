using <stdint.h>::{size_t, uint8_t};
using <stdlib.h>::{abort, sizeof};
using <string.h>::{memset};
using <stdio.h>::{fprintf};

struct Pool {
    size_t          slab;
    size_t          count;
    uint8_t mut*    free;
    uint8_t mut*    pool;
}


pub fn size(size_t slab, size_t count) -> size_t {
    return sizeof(Pool) + (slab * count) + (count / 8) + 1;
}

pub macro MAKE (NAME, SLAB, COUNT) {
    char mut NAME [size(SLAB,COUNT)];
    init(NAME, SLAB, COUNT);
}

pub fn init(char mut* b, size_t slab, size_t count) {
    memset(b, 0, sizeof(Pool) + slab * count + count / 8 + 1);
    Pool mut* self = (Pool mut*)b;

    self->slab  = slab;
    self->count = count;
    self->free  = ((uint8_t mut*)b) + sizeof(Pool);
    self->pool  = self->free + count / 8 + 1;
}

pub fn alloc(char mut* b) -> void* {
    Pool mut* self = (Pool mut*)b;
    for (int mut i = 0; i < self->count; i+=1 ) {
        if ((self->free[i/8] & (1 << (i%8))) == 0) {
            self->free[i/8] |= (1 << (i%8));
            return self->pool + (i * self->slab);
        }
    }
    return 0;
}

pub fn release(char mut* b, void* mem) -> void* {
    Pool* self = (Pool mut*)b;

    size_t slot = ((uint8_t*)mem - self->pool) / self->slab;

    if (slot >= self->count || (self->pool + (self->slab * slot)) != mem) {
        fprintf(stderr, "internal error: pointer %x passed to fl:free was never allocated from this fl pool\n", mem);
        abort();
    }

    self->free[slot / 8] &= ~(1 << (slot % 8));

    return 0;
}



