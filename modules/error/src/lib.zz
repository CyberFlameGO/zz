using libc::stdint::{uint8_t};
using libc::stdio::{printf, snprintf};
using libc::string::{memset};
using libc::errno::{errno};

export struct Error {
    uint8_t error;
    char    description[255];
    char    locations[255];
};



pub fn mark_moved(Error move mut *err) {
}

pub macro perror(err, text) {
    (err)->error = (err)->error || errno || EINVAL;
    snprintf((err)->description, sizeof((err)->description), text);
    memset((err)->locations, 0, sizeof((err)->locations));
    snprintf(
            (char mut*)(&((err)->locations)) + strlen((err)->locations),
            sizeof((err)->locations) - strlen((err)->locations),
            "\n  %s:%d", __FILE__, __LINE__);
    mark_moved(err);
}

pub macro ECHECK() {
    if (err->error != 0) {
        snprintf(
                (char mut*)(&((err)->locations)) + strlen((err)->locations),
                sizeof((err)->locations) - strlen((err)->locations),
                "\n  %s:%d", __FILE__, __LINE__);
        goto exit ;
    }
}

pub macro try(expr) {
    expr;
    if (err->error != 0) {
        snprintf(
                (char mut*)&((err)->locations) + strlen((err)->locations),
                sizeof((err)->locations) - strlen((err)->locations),
                "\n  %s:%d", __FILE__, __LINE__);
        goto exit ;
    }
}

pub macro FAIL(text) {
    (err)->error = (err)->error || errno || EINVAL;
    snprintf((err)->description, sizeof((err)->description), text);
    memset((err)->locations, 0, sizeof((err)->locations));
    ECHECK
}

pub macro throw(text) {
    (err)->error = (err)->error || errno || EINVAL;
    snprintf((err)->description, sizeof((err)->description), text);
    memset((err)->locations, 0, sizeof((err)->locations));
    snprintf(
            (char*)&((err)->locations) + strlen((err)->locations),
            sizeof((err)->locations) - strlen((err)->locations),
            "\n  %s:%d", __FILE__, __LINE__);
    goto exit ;
}

pub macro FAILV(text, ...) {
    (err)->error = (err)->error || errno || EINVAL;
    snprintf((err)->description, sizeof((err)->description), text, __VA_ARGS__ );
    memset((err)->locations, 0, sizeof((err)->locations));
    ECHECK;
}

export macro ABORT() {
    if (err->error != 0) {
        snprintf(
                (char mut*)&((err)->locations) + strlen((err)->locations),
                sizeof((err)->locations) - strlen((err)->locations),
                "\n  %s:%d", __FILE__, __LINE__);
        fprintf(stderr, "%s%s\n", err->description, err->locations);
        abort();
    }
}

pub macro check_noise_error(e) {
    if ((e) != 0) {
        char buf[255];
        noise_strerror((e), buf, 255);
        EFAILV("%s", buf);
    }
}

pub macro HEXDUMP(v, len) {
    for(int i=0; i < len; i+=1) {
        printf(" %02x", ((uint8_t*)(v))[i]);
        if (i % 32 == 31) {
            putchar('\n');
        }
    }
    putchar('\n');
}

export fn error_to_str(Error* err, char mut* buf, int buflen) {
    memset(buf, 0, buflen);
    snprintf(buf, buflen, "%s%s", err->description, err->locations);
}
