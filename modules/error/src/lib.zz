using <stdint.h>::{uint8_t};
using <stdio.h>::{printf, snprintf, vsnprintf, fprintf, stderr};
using <string.h>::{memset, strncat};
using <errno.h>::{errno};
using <stdlib.h>::{abort as cabort};
using <stdarg.h>::{va_list, va_start};

export struct Error {
    uint8_t mut error;
    char    description[255];
    char    locations[255];
};


export fn clear(Error unset<error> mut* err) {
    memset(err, 0, sizeof(Error));
}

export  fn check(
        Error unset<error> mut* err,
        char* callsite_macro<__FILE__>      unsafe file,
        char* callsite_macro<__FUNCTION__>  unsafe scope,
        int   callsite_macro<__LINE__>      line,
        ) -> int {

    if ((err)->error != 0) {
        backtrace(err, file, scope, line);
        return (err)->error;
    }
    return 0;
}


export fn backtrace(Error allow<error> mut* err, char* file, char* scope, int line) {
    snprintf(
            (char mut*)(&((err)->locations)) + strlen((err)->locations),
            sizeof((err)->locations) - strlen((err)->locations),
            "\n  %s:%d \t%s", file, line, scope);
}

export fn fail_with_errno(
        Error unset<error> set<error> mut* err,
        char* callsite_macro<__FILE__>      unsafe file,
        char* callsite_macro<__FUNCTION__>  unsafe scope,
        int   callsite_macro<__LINE__>      line,
        char*  fmt,
        ...
        ) {
    (err)->error = errno;

    va_list mut vargs;
    va_start(vargs, fmt);
    vsnprintf((err)->description, sizeof((err)->description), fmt, vargs);

    strncat((err)->description, " : ", sizeof((err)->description) - strlen((err)->description));
    strncat((err)->description, strerror(errno), sizeof((err)->description) - strlen((err)->description));

    memset((err)->locations, 0, sizeof((err)->locations));

    backtrace(err, file, scope, line);
}

export fn fail(
        Error unset<error> set<error> mut* err,
        uint8_t e,
        char* callsite_macro<__FILE__>      unsafe file,
        char* callsite_macro<__FUNCTION__>  unsafe scope,
        int   callsite_macro<__LINE__>      line,
        char*  fmt,
        ...
        ) {
    err is safe;
    (err)->error = e;

    va_list mut vargs;
    va_start(vargs, fmt);
    vsnprintf((err)->description, sizeof((err)->description), fmt, vargs);

    memset((err)->locations, 0, sizeof((err)->locations));

    backtrace(err, file, scope, line);
}

export fn abort(
        Error unset<error> mut* err,
        char* callsite_macro<__FILE__>      unsafe file,
        char* callsite_macro<__FUNCTION__>  unsafe scope,
        int   callsite_macro<__LINE__>      line,
) {
    if (err->error != 0) {
        backtrace(err, file, scope, line);
        fprintf(stderr, "fatal error: %s%s\n", err->description, err->locations);
        cabort();
    }
}

export fn to_str(
        Error mut* err,
        char mut *dest,
        usize dest_len,
) {
    snprintf(dest, dest_len, "%s%s\n", err->description, err->locations);
}
