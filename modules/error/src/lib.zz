using <stdint.h>::{uint8_t};
using <stdio.h>::{printf, snprintf, vsnprintf};
using <string.h>::{memset};
using <errno.h>::{errno};
using <stdlib.h>::{abort};
using <stdarg.h>::{va_list, va_start};

export struct Error {
    uint8_t error;
    char    description[255];
    char    locations[255];
};

pub fn check(
        Error untaint<Error> mut* err,
        char* callsite_macro<__FILE__>      file,
        char* callsite_macro<__FUNCTION__>  scope,
        int   callsite_macro<__LINE__>      line,
        ) -> int {
    if ((err)->error != 0) {
        snprintf(
                (char mut*)(&((err)->locations)) + strlen((err)->locations),
                sizeof((err)->locations) - strlen((err)->locations),
                "\n  %s:%d %s", file, line, scope);
        return (err)->error;
    }
    return 0;
}

pub fn fail(
        Error untaint<Error> taint<Error> mut* err,
        uint8_t e,
        char* callsite_macro<__FILE__>      file,
        char* callsite_macro<__FUNCTION__>  scope,
        int   callsite_macro<__LINE__>      line,
        char*  fmt,
        ...
        ) {

    (err)->error = e;

    va_list mut vargs;
    va_start(vargs, fmt);
    vsnprintf((err)->description, sizeof((err)->description), fmt, vargs);

    memset((err)->locations, 0, sizeof((err)->locations));

    snprintf(
            (char mut*)(&((err)->locations)) + strlen((err)->locations),
            sizeof((err)->locations) - strlen((err)->locations),
            "\n  %s:%d %s", file, line, scope);
}

export macro ABORT(err) {
    if (err->error != 0) {
        snprintf(
                (char mut*)&((err)->locations) + strlen((err)->locations),
                sizeof((err)->locations) - strlen((err)->locations),
                "\n  %s:%d %s", __FILE__, __LINE__, __FUNCTION__);
        fprintf(stderr, "%s%s\n", err->description, err->locations);
        abort();
    }
}
