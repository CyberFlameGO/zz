using <stdio.h>::{printf, snprintf, vsnprintf, fprintf, stderr};
using <string.h>::{memset, strncat, strlen};
using <errno.h>::{errno, strerror};
using <stdlib.h>::{abort as cabort};
using <stdarg.h>::{va_list, va_start};


theory checked(Err * self) -> bool;

export struct Err+ {
    u8      mut error;
    char    description[255];
    char    locations[];
};


export fn new(Err+tail mut * err)
    model checked(*err)
{
    memset(err, 0, sizeof(Err));
    memset(err->locations, 0, tail);
    static_attest(checked(*err));
}

export  fn check(
        Err+tail mut* err,
        char* callsite_source<file>      unsafe file,
        char* callsite_source<function>  unsafe scope,
        int   callsite_source<line>      line,
) -> bool
    model checked(*err)
{
    static_attest(checked(*err));
    if ((err)->error != 0) {
        backtrace(err, file, scope, line);
        return true;
    }
    return false;
}


fn backtrace(Err+tail mut* err, char * unsafe file, char * unsafe scope, int line)
{
    snprintf(
        (char mut*)(&((err)->locations)) + as<usize>(strlen((err)->locations)),
        tail- as<usize>(strlen((err)->locations)),
        "\n  %s:%d \t%s", file, line, scope);
}

export fn fail_with_errno(
        Err+tail mut* err,
        char* callsite_source<file>      unsafe file,
        char* callsite_source<function>  unsafe scope,
        int   callsite_source<line>      line,
        char*  fmt,
        ...
)
    where checked(*err)
{
    (err)->error = (u8)errno;

    va_list mut vargs;
    va_start(vargs, fmt);
    vsnprintf((err)->description, sizeof((err)->description), fmt, vargs);

    strncat((err)->description, " : ", as<usize>(sizeof((err)->description)) - as<usize>(strlen((err)->description)));
    strncat((err)->description, strerror(errno), as<usize>(sizeof((err)->description)) - as<usize>(strlen((err)->description)));

    memset((err)->locations, 0, tail);

    backtrace(err, file, scope, line);
}

export fn fail(
        Err+tail mut* err,
        u8  e,
        char* callsite_source<file>      unsafe file,
        char* callsite_source<function>  unsafe scope,
        int   callsite_source<line>      line,
        char*  fmt,
        ...
)
    where checked(*err)
{
    (err)->error = e;

    va_list mut vargs;
    va_start(vargs, fmt);
    vsnprintf((err)->description, sizeof((err)->description), fmt, vargs);

    memset((err)->locations, 0, tail);

    backtrace(err, file, scope, line);
}

export fn abort(
        Err+tail mut* err,
        char* callsite_source<file>      unsafe file,
        char* callsite_source<function>  unsafe scope,
        int   callsite_source<line>      line,
)

model checked(*err)

{
    static_attest(checked(*err));
    if (err->error != 0) {
        backtrace(err, file, scope, line);
        fprintf(stderr, "fatal error: %s%s\n", err->description, err->locations);
        cabort();
    }
}

export fn to_str(
    Err mut* err,
    char mut *dest,
    usize dest_len,
)
{
    snprintf(dest, dest_len, "%s%s\n", err->description, err->locations);
}
