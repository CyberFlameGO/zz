using string;
using err;

using <stdio.h>::{printf};
using <arpa/inet.h>::{inet_pton, htons, inet_aton, ntohs};
using <string.h>::{memset, strlen};
using <netinet/in.h>::{
    (struct sockaddr_in)    as SockAddrIn,
    (struct sockaddr)       as SockAddr,
    (struct in_addr)        as InnetAddr,
};


export struct Address {
    SockAddrIn posix;
}

export fn from_cstr(err::Err+et mut*e, Address mut* to, char *s) -> bool
    where err::checked(*e)
{
    usize slen = as<usize>(strlen(s));
    static_attest(len(s) >= slen);

    memset(&to->posix, 0, sizeof(SockAddrIn));
    @{{
        to->posix.sin_family      = AF_INET;
    }}@


    u8 mut *mut ip;
    u16 mut* mut port;
    @{{
        ip      = (void*)&(to->posix.sin_addr.s_addr);
        port    = &(to->posix.sin_port);
    }}@
    static_attest(len(ip) == 4);
    static_attest(safe(port));

    usize mut at = 0;

    for(usize mut i = 0; i < slen; i++) {
        char ch = s[i];
        if ch >= '0' && ch <= '9' {
            uint nv = as<uint>(ip[at] * 10) + as<uint>(ch - '0');
            if nv > 255 {
                err::fail(e, 22, "u8 overflow at %zu", i);
                return false;
            }
            ip[at] = as<u8>(nv);
        } else if ch == '.' {
            at += 1;
            if at == 4 {
                err::fail(e, 22, "unexpected . at %zu", i);
                return false;
            }
        } else if ch == ':' {
            i += 1;
            for(; i < slen; i++) {
                char ch = s[i];
                if ch >= '0' && ch <= '9' {
                    uint nv = as<uint>(*port * 10) + as<uint>(ch - '0');
                    if nv > 65535 {
                        err::fail(e, 22, "u16 overflow . at %zu", i);
                        return false;
                    }
                    *port =  as<u16>(nv);
                } else {
                    err::fail(e, 22, "unexpected '%c' at %zu", ch, i);
                    return false;
                }
            }
        } else {
            err::fail(e, 22, "unexpected '%c' at %zu", ch, i);
            return false;
        }
    }
    *port = as<u16>(htons(*port));
    if at != 3 {
        err::fail(e, 22, "not enough parts");
        return false;
    }
    return true;
}


export fn to_string(string::String+st mut*to, Address * from)
    where st>0
{
    u8 * mut ip;
    u16 * mut port;
    @{{
        ip      = (void*)&(from->posix.sin_addr.s_addr);
        port    = &(from->posix.sin_port);
    }}@
    static_attest(len(ip) == 4);
    static_attest(safe(port));

    string::format(to, "%u.%u.%u.%u:%u",
        ip[0],
        ip[1],
        ip[2],
        ip[3],
        ntohs(*port)
    );
}



export fn set_port(Address mut*self, u16 port) {
    @{{
        self->posix.sin_port = htons(port);
    }}@
}

export fn get_port(Address *self) -> u16 {
    @{{
        return ntohs(self->posix.sin_port);
    }}@
}
