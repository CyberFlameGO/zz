using address;
using string;
using err;
using time;

using <sys/socket.h> as posix_socket;
using <arpa/inet.h>::{IPPROTO_UDP};
using <unistd.h> as unistd;
using <netinet/in.h>::{
    (struct sockaddr_in6)   as SockAddrIn,
    (struct sockaddr)       as SockAddr,
};

using <sys/time.h>::{
    (struct timeval) as Timeval
};


export struct Socket {
    int fd;
}

export fn close(Socket mut *self)
{
    if self->fd >= 0 {
        unistd::close(self->fd);
    }
    self->fd = 0;
}

export fn open(Socket mut *self, err::Err+et mut*e, address::Type addrtype)
    where err::checked(*e)
{
    if self->fd != 0 {
        close(self);
    }

    switch addrtype {
        address::Type::Ipv6 => {
            self->fd = as<int>(posix_socket::socket(posix_socket::AF_INET6, posix_socket::SOCK_DGRAM, IPPROTO_UDP));
        }
        address::Type::Ipv4 => {
            self->fd = as<int>(posix_socket::socket(posix_socket::AF_INET, posix_socket::SOCK_DGRAM, IPPROTO_UDP));
        }
    }

    if self->fd < 0 {
        err::fail_with_errno(e, "socket");
        return;
    }

    unsafe {
        int v = 1;
        posix_socket::setsockopt(self->fd, posix_socket::SOL_SOCKET, posix_socket::SO_REUSEADDR, (void*)&v, sizeof(int));
    }
}

export fn bind(Socket mut *self, err::Err+et mut*e, address::Address *addr)
    where err::checked(*e)
{
    if self->fd != 0 {
        close(self);
    }

    switch addr->type {
        address::Type::Ipv6 => {
            self->fd = as<int>(posix_socket::socket(posix_socket::AF_INET6, posix_socket::SOCK_DGRAM, IPPROTO_UDP));
        }
        address::Type::Ipv4 => {
            self->fd = as<int>(posix_socket::socket(posix_socket::AF_INET, posix_socket::SOCK_DGRAM, IPPROTO_UDP));
        }
    }

    if self->fd < 0 {
        err::fail_with_errno(e, "socket");
        return;
    }

    unsafe {
        int v = 1;
        posix_socket::setsockopt(self->fd, posix_socket::SOL_SOCKET, posix_socket::SO_REUSEADDR, (void*)&v, sizeof(int));
    }

    int r = as<int>(posix_socket::bind(self->fd, as<SockAddr*>(&addr->posix), sizeof(SockAddrIn)));
    if r != 0 {
        err::fail_with_errno(e, "bind");
    }
}

export fn sendto(Socket mut *self, err::Err+et mut*e, address::Address *to, u8*msg, usize msglen)
    where err::checked(*e)
    where len(msg) >= msglen
{
    int r = as<int>(posix_socket::sendto(self->fd, msg, msglen, 0, as<SockAddr*>(&to->posix), sizeof(SockAddrIn)));
    if r != 0 {
        err::fail_with_errno(e, "bind");
    }
}

export fn recv(Socket mut *self, err::Err+et mut*e, string::String+st mut *buf, address::Address mut*from)
    where err::checked(*e)
{
    uint mut alen = (uint)sizeof(SockAddrIn);

    int r = as<int>(posix_socket::recvfrom(
        self->fd,
        buf->mem + buf->len,
        st - buf->len ,
        0,
        as<SockAddr mut*>(&from->posix),
        &alen
    ));

    unsafe {
        if ((from->posix).v6).sin6_family  == posix_socket::AF_INET6 {
            from->type = address::Type::Ipv6;
        }
    }

    if r < 1 {
        err::fail_with_errno(e, "recv");
        return;
    }
    buf->len += as<usize>(r);
}

export fn deadline(Socket mut *self, err::Err+et mut*e, time::Time dur)
    where err::checked(*e)
{
    Timeval v = Timeval {
        tv_sec:     dur.secs,
        tv_usec:    (dur.nano * 1000),
    };

    if ((int)posix_socket::setsockopt (self->fd, posix_socket::SOL_SOCKET, posix_socket::SO_RCVTIMEO, (char *)&v, sizeof(Timeval)) < 0) {
        err::fail_with_errno(e, "setsockopt");
    }
}
