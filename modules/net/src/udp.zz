using address;
using string;
using err;
using io;

inline using (needs
    err::Err,
    err::fail_with_errno,
    err::fail,
    io::Context,
    address::Type,
    address::Address,
    io::Result
) "os.h"::{
    os_net_udp_bind,
    os_net_udp_close,
    os_net_udp_make_async,
    os_net_udp_recvfrom,
    os_net_udp_sendto,
};

export struct Socket {
    io::Context ctx;
}


export fn bind(err::Err+et mut*e, address::Address *addr) -> Socket
    where err::checked(*e)
{
    io::Context mut ctx;
    os_net_udp_bind(e, et, addr, &ctx);

    return Socket {
        ctx: ctx
    };
}


export fn bind_async(err::Err+et mut*e, address::Address *addr, io::Async mut* async) -> Socket
    where err::checked(*e)
{
    io::Context mut ctx;
    os_net_udp_bind(e, et, addr, &ctx);
    if err::check(e) {
        return Socket {
            ctx: ctx
        };
    }

    os_net_udp_make_async(e, et, &ctx);
    ctx.async = async;

    return Socket {
        ctx: ctx
    };
}


export fn close(Socket mut* self) {
    os_net_udp_close(self->ctx);
}

export fn recvfrom(Socket mut *self, err::Err+et mut*e, string::String+st mut *buf, address::Address mut*from) -> io::Result
    where err::checked(*e)
{

    if (self->ctx).async != 0 {
        static_attest(safe((self->ctx).async));
        io::select(((self->ctx).async), e, &self->ctx, io::Ready::Read);
        if err::check(e) {
            return io::Result::Error;
        }
    }

    static_attest(len(buf->mem) > buf->len);
    usize mut l = 0;
    io::Result rr = (io::Result)os_net_udp_recvfrom(e, et, &self->ctx, buf->mem + buf->len, buf->len - st, from, &l);
    if err::check(e) {
        return rr;
    }
    buf->len += l;
    return rr;
}

export fn sendto(Socket mut *self, err::Err+et mut*e, string::String+st *buf, address::Address * to)
    where err::checked(*e)
{
    static_attest(len(buf->mem) > buf->len);
    os_net_udp_sendto(e, et, &self->ctx, buf->mem, buf->len , to);
    if err::check(e) {
        return;
    }
}
