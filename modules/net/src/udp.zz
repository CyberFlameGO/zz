using address;
using string;
using err;
using io;

inline using(needs err::Err, err::fail_with_errno, err::fail, io::Context, address::Type, address::Address) "os.h"::{
    _os_net_udp_bind,
    _os_net_udp_close,
};

export struct Socket {
    io::Context ctx;
}


export fn bind(err::Err+et mut*e, address::Address *addr) -> Socket
    where err::checked(*e)
{
    io::Context mut ctx;
    _os_net_udp_bind(e, et, addr, &ctx);
    return Socket {
        ctx: ctx
    };
}



export fn close(Socket mut* self) {
    _os_net_udp_close(self->ctx);
}


/*

export fn bind(Socket mut *self, err::Err+et mut*e, address::Address *addr)
    where err::checked(*e)
{
    if self->fd != 0 {
        close(self);
    }

    switch addr->type {
        address::Type::Ipv6 => {
            self->fd = as<int>(posix_socket::socket(posix_socket::AF_INET6, posix_socket::SOCK_DGRAM, IPPROTO_UDP));
        }
        address::Type::Ipv4 => {
            self->fd = as<int>(posix_socket::socket(posix_socket::AF_INET, posix_socket::SOCK_DGRAM, IPPROTO_UDP));
        }
    }

    if self->fd < 0 {
        err::fail_with_errno(e, "socket");
        return;
    }

    unsafe {
        int v = 1;
        posix_socket::setsockopt(self->fd, posix_socket::SOL_SOCKET, posix_socket::SO_REUSEADDR, (void*)&v, sizeof(int));
    }

    int r = as<int>(posix_socket::bind(self->fd, as<SockAddr*>(&addr->posix), sizeof(SockAddrIn)));
    if r != 0 {
        err::fail_with_errno(e, "bind");
    }
}

export fn sendto(Socket mut *self, err::Err+et mut*e, address::Address *to, u8*msg, usize msglen)
    where err::checked(*e)
    where len(msg) >= msglen
{
    int r = as<int>(posix_socket::sendto(self->fd, msg, msglen, 0, as<SockAddr*>(&to->posix), sizeof(SockAddrIn)));
    if r != 0 {
        err::fail_with_errno(e, "bind");
    }
}

export fn recv(Socket mut *self, err::Err+et mut*e, string::String+st mut *buf, address::Address mut*from)
    where err::checked(*e)
{
    uint mut alen = (uint)sizeof(SockAddrIn);

    static_attest(len(buf->mem) > buf->len);

    int r = as<int>(posix_socket::recvfrom(
        self->fd,
        buf->mem + buf->len,
        st - buf->len ,
        0,
        as<SockAddr mut*>(&from->posix),
        &alen
    ));

    unsafe {
        if ((from->posix).v6).sin6_family  == posix_socket::AF_INET6 {
            from->type = address::Type::Ipv6;
        }
    }

    if r < 1 {
        err::fail_with_errno(e, "recv");
        return;
    }
    buf->len += as<usize>(r);
}

*/


/*
using <sys/time.h>::{ (struct timeval) as Timeval
export fn deadline(Socket mut *self, err::Err+et mut*e, time::Time dur)
    where err::checked(*e)
{
    Timeval v = Timeval {
        tv_sec:     dur.secs,
        tv_usec:    (dur.nano * 1000),
    };

    if ((int)posix_socket::setsockopt (self->fd, posix_socket::SOL_SOCKET, posix_socket::SO_RCVTIMEO, (char *)&v, sizeof(Timeval)) < 0) {
        err::fail_with_errno(e, "setsockopt");
    }
}

*/
