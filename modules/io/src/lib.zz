using time;
using string;
using err;

using <stdio.h>::{printf};

export struct Async {
    //make_timeout_fn
    void unsafe *make_timeout;
    //wake_fn
}


export enum Wake {
    Read,
    Write,
}

export enum Result {
    Ready,
    Later,
    Error,
    Eof,
}

export fntype read_fn  (Context mut* ctx, err::Err+et mut* e, u8 mut* to, usize mut* len) -> Result;
export fntype write_fn (Context mut* ctx, err::Err+et mut* e, u8* to, usize mut* len) -> Result;
export fntype wake_fn  (Context mut* ctx, err::Err+et mut* e, Wake w);
export fntype close_fn (Context mut* ctx);


export struct Context {
    int         fd;
    void*       handle;
    u64         time;

    Async mut* unsafe async;
}

export struct Io {
    read_fn     read_impl;
    write_fn    write_impl;
    close_fn    close_impl;
    wake_fn     wake_impl;
    Context     ctx;
}

export fn read(Io mut* self, err::Err+et mut* e, string::String+st mut* str) -> Result
    where st > 1
    where err::checked(*e)
    where str->len < st
{
    if self->read_impl == 0 {
        err::fail(e, 1, "noimpl");
        return Result::Error;
    }
    static_attest(safe(self->read_impl));

    usize mut l = st - str->len - 1;
    Result rr = self->read_impl(&self->ctx, e, as<u8 mut*>(str->mem + str->len), &l);
    err::check(e);
    if rr != Result::Ready {
        return rr;
    }
    str->len += l;
    static_attest(len(str->mem) > str->len);
    (str->mem)[str->len] = 0;
    return rr;
}

export fn readline(Io mut* self, err::Err+et mut* e, string::String+st mut* str) -> Result
    where st > 1
    where err::checked(*e)
    where str->len < st
    where st > 2
{
    if self->read_impl == 0 {
        err::fail(e, 1, "noimpl");
        return Result::Error;
    }
    static_attest(safe(self->read_impl));

    u8 mut buf[2] = {0};
    usize mut l = 1;
    Result rr = self->read_impl(&self->ctx, e, buf, &l);
    err::check(e);
    if rr != Result::Ready {
        return rr;
    }

    char ch = as<char>(buf[0]);

    if ch == '\n' || ch == '\r' {
        return Result::Ready;
    }

    if !str->push(ch) {
        err::fail(e, 1, "oom");
        return Result::Error;
    }

    return Result::Later;
}

export fn write(Io mut* self, err::Err+et mut* e, string::String+st mut* str) -> Result
    where st > 1
    where err::checked(*e)
    where str->len < len(str->mem)
{
    if self->write_impl == 0 {
        err::fail(e, 1, "noimpl");
        return Result::Error;
    }
    static_attest(safe(self->write_impl));

    usize mut l = str->len;
    Result rr = self->write_impl(&self->ctx, e, as<u8 mut*>(str->mem + str->len), &l);
    err::check(e);
    if rr != Result::Ready {
        return rr;
    }
    return rr;
}

export fn write_bytes(Io mut* self, err::Err+et mut* e, u8 *b, usize mut *blen) -> Result
    where err::checked(*e)
{
    if self->write_impl == 0 {
        err::fail(e, 1, "noimpl");
        return Result::Error;
    }
    static_attest(safe(self->write_impl));

    Result rr = self->write_impl(&self->ctx, e, b, blen);
    err::check(e);
    if rr != Result::Ready {
        return rr;
    }
    return rr;
}

export fn close(Io mut* self)
{
    if self->close_impl == 0 {
        return;
    }
    static_attest(safe(self->close_impl));
    self->close_impl(&self->ctx);
}

export fn wake(Io mut*self, err::Err+et mut* e, Wake w)
    where err::checked(*e)
{
    if self->wake_impl == 0 {
        return;
    }
    static_attest(safe(self->wake_impl));
    self->wake_impl(&self->ctx,e,w);
}

pub fn drop(Io mut* self) {
    close(self);
}


export fntype make_timeout_fn(Async *async, err::Err+et mut*e, time::Time t2) -> Io;
// TODO cannot use self function because flatten makes it a recursive type
export fn timeout(Async mut* this, err::Err+et mut*e, time::Time t2) -> Io
    where err::checked(*e)
{
    if this->make_timeout != 0 {
        make_timeout_fn make_timeout = (make_timeout_fn)this->make_timeout;
        static_attest(safe(make_timeout));
        return make_timeout(this, e, t2);
    }
    return Io{
        read_impl: 0,
    };
}


