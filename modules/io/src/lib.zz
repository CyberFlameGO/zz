using time;
using string;
using err;

using <stdio.h>::{printf};

export struct Async {
    //make_timeout_fn
    void unsafe *make_timeout;
    //wake_fn
}


export enum Wake {
    Read,
    Write,
}

export enum Result {
    Ready,
    Later,
    Error,
    Eof,
}

export fntype read_fn  (Context ctx, err::Err+et mut* e, u8 mut* to, usize mut* len) -> Result;
export fntype write_fn (Context ctx, err::Err+et mut* e, u8 mut* to, usize mut* len) -> Result;
export fntype wake_fn  (Context ctx, err::Err+et mut* e, Wake w);
export fntype close_fn (Context ctx);


export struct Context {
    int         fd;
    void*       handle;
    u64         time;

    Async mut* unsafe async;
}

export struct Io {
    read_fn     read_impl;
    write_fn    write_impl;
    close_fn    close_impl;
    wake_fn     wake_impl;
    Context     ctx;
}

export fn read(Io mut* self, err::Err+et mut* e, string::String+st mut* str) -> Result
    where st > 1
    where err::checked(*e)
{
    if self->read_impl != 0 {
        static_attest(safe(self->read_impl));

        usize mut l = st - str->len - 1;
        Result rr = self->read_impl(self->ctx, e, as<u8 mut*>(str->mem + str->len), &l);
        err::check(e);
        if rr != Result::Ready {
            return rr;
        }
        str->len += l;
        static_attest(len(str->mem) > str->len);
        (str->mem)[str->len] = 0;
        return rr;
    } else {
        err::fail(e, 1, "noimpl");
        return Result::Error;
    }
}

export fn close(Io mut* self)
{
    if self->close_impl == 0 {
        return;
    }
    static_attest(safe(self->close_impl));
    self->close_impl(self->ctx);
}

export fn wake(Io *self, err::Err+et mut* e, Wake w)
    where err::checked(*e)
{
    if self->wake_impl == 0 {
        return;
    }
    static_attest(safe(self->wake_impl));
    self->wake_impl(self->ctx,e,w);
}

pub fn drop(Io mut* self) {
    close(self);
}


export fntype make_timeout_fn(Async *async, err::Err+et mut*e, time::Time t2) -> Io;
// TODO cannot use self function because flatten makes it a recursive type
export fn timeout(Async mut* this, err::Err+et mut*e, time::Time t2) -> Io
    where err::checked(*e)
{
    if this->make_timeout != 0 {
        make_timeout_fn make_timeout = (make_timeout_fn)this->make_timeout;
        static_attest(safe(make_timeout));
        return make_timeout(this, e, t2);
    }
    return Io{
        read_impl: 0,
    };
}


