using <stdint.h>::{intptr_t};
using <assert.h>::{assert};
using <stddef.h>::{size_t, sizeof};

struct warloc_pool {
    size_t mut size;
    size_t mut used;
};


thread_local warloc_pool* mut thread_local_pool = 0;

const size_t ALIGN_TO = sizeof(intptr_t) * 2;
pub fn into_warloc_pool(void mut unsafe* mut mem, size_t mut size) -> void mut* {
    assert(size >= ALIGN_TO * 2);

    mem += (ALIGN_TO  - ((intptr_t)mem % ALIGN_TO));

    warloc_pool mut* pool = (warloc_pool mut*)mem;
    pool is safe;

    pool->size = size - sizeof(size_t) + sizeof(size_t);
    pool->used = 0;


    thread_local_pool = pool;

    return mem;
}

pub fn as_warloc_pool(void mut* mut mem) -> void mut* {
    mem += (ALIGN_TO  - ((intptr_t)mem % ALIGN_TO));
    return mem;
}

export fn malloc(size_t mut s) -> void mut* {
    assert(thread_local_pool != 0);
    thread_local_pool is safe;
    *thread_local_pool is mutable;
    *thread_local_pool is safe;
    return warloc((char mut*)thread_local_pool, s);
}

export fn warloc(char mut* mem, size_t mut s) -> void mut* {
    warloc_pool mut* pool = (warloc_pool mut*)mem;
    pool is safe;

    s += (ALIGN_TO  - (s % ALIGN_TO));
    //printf("alloc %d out of %d/%d\n", s, pool->used,pool->size);
    if (pool->size - pool->used < s) {
        //printf("oom");
        return 0;
    }

    void mut* r = mem + (sizeof(size_t) + sizeof(size_t) + pool->used);
    pool->used += s;
    return r;
}
